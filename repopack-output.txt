================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-09-19T17:59:56.328Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
authMiddleware.js
authRoutes.js
catRoutes.js
db.js
package.json
petRoutes.js
server.js

================================================================
Repository Files
================================================================

================
File: authRoutes.js
================
const jwt = require('jsonwebtoken');

const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (token == null) return res.sendStatus(401);

  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    if (err) return res.sendStatus(403);
    req.user = user;
    next();
  });
};

module.exports = { authenticateToken };

================
File: catRoutes.js
================
const express = require('express');
const { OpenAI } = require('openai');
const { pool } = require('./db');
const { authenticateToken } = require('./authMiddleware');

const router = express.Router();

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

async function analyzeCatEmotion(base64Image) {
  const prompt = `You are an AI picture analysis assistant that helps me figure out the emotion of a cat based off of a given picture which I have provided. First check to see if the animal is a cat. If the animal is a cat, only send back a one word response of the emotion of the cat from the following categories: ["Content", "Happy", "Curious", "Affectionate", "Scared", "Aggressive", "Annoyed", "Anxious", "Sad", "Bored", "Sleepy"]
  
  If the animal is not a cat, send back this message strictly: 'ERROR: not a cat'`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4-vision-preview",
      messages: [
        {
          role: "user",
          content: [
            { type: "text", text: prompt },
            {
              type: "image_url",
              image_url: {
                "url": `data:image/jpeg;base64,${base64Image}`,
                "detail": "low"
              },
            },
          ],
        },
      ],
      max_tokens: 300
    });

    return response.choices[0].message.content;
  } catch (error) {
    console.error('Error:', error);
    throw error;
  }
}

router.post('/analyze', authenticateToken, async (req, res) => {
  const { image, petId } = req.body;

  if (!image || !petId) {
    return res.status(400).json({ error: 'Image and petId are required' });
  }

  try {
    const result = await analyzeCatEmotion(image);
    
    // Store the emotion record in the database
    const client = await pool.connect();
    try {
      await client.query('BEGIN');
      const emotionRecordResult = await client.query(
        'INSERT INTO emotion_records (pet_id, emotion, image_url) VALUES ($1, $2, $3) RETURNING id',
        [petId, result, image]
      );
      const emotionRecordId = emotionRecordResult.rows[0].id;

      // Get emotion details
      const emotionDetails = await openai.chat.completions.create({
        model: "gpt-4",
        messages: [{
          role: "user",
          content: `Return only a valid JSON object with the following structure, and no other text:
          {
            "description": "A sentence of what it means for a cat to be ${result} and how to identify it.",
            "tipsAndRecs": ["Tip 1", "Tip 2", "Tip 3"]
          }
          The tips and recommendations should be about what to do when a cat is in this emotional state.`
        }]
      });

      const parsedEmotionDetails = JSON.parse(emotionDetails.choices[0].message.content);

      // Update emotion record with description
      await client.query(
        'UPDATE emotion_records SET emotion_text = $1 WHERE id = $2',
        [parsedEmotionDetails.description, emotionRecordId]
      );

      // Store tips and recommendations
      for (const tip of parsedEmotionDetails.tipsAndRecs) {
        await client.query(
          'INSERT INTO tips_and_recs (emotion_record_id, tip) VALUES ($1, $2)',
          [emotionRecordId, tip]
        );
      }

      await client.query('COMMIT');
      res.json({ message: result, emotionDetails: parsedEmotionDetails });
    } catch (dbError) {
      await client.query('ROLLBACK');
      throw dbError;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: 'An error occurred while analyzing the image', details: error.message });
  }
});

router.post('/get-emotion-details', authenticateToken, async (req, res) => {
  const { emotion } = req.body;

  if (!emotion) {
    return res.status(400).json({ error: 'Emotion is required' });
  }

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [{
        role: "user",
        content: `Return only a valid JSON object with the following structure, and no other text:
        {
          "description": "A sentence of what it means for a cat to be ${emotion} and how to identify it.",
          "tipsAndRecs": ["Tip 1", "Tip 2", "Tip 3"]
        }
        The tips and recommendations should be about what to do when a cat is in this emotional state.`
      }]
    });

    const result = JSON.parse(response.choices[0].message.content);
    res.json(result);
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: 'An error occurred while getting emotion details', details: error.message });
  }
});

module.exports = router;

================
File: db.js
================
const express = require('express');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const { pool } = require('./db');

const router = express.Router();

router.post('/register', async (req, res) => {
  const { username, email, password } = req.body;
  
  if (!username || !email || !password) {
    return res.status(400).json({ error: 'Username, email, and password are required' });
  }

  try {
    const hashedPassword = await bcrypt.hash(password, 10);
    const result = await pool.query(
      'INSERT INTO users (username, email, password) VALUES ($1, $2, $3) RETURNING id',
      [username, email, hashedPassword]
    );
    res.status(201).json({ id: result.rows[0].id, message: 'User registered successfully' });
  } catch (error) {
    console.error('Error registering user:', error);
    res.status(500).json({ error: 'An error occurred while registering the user' });
  }
});

router.post('/login', async (req, res) => {
  const { username, password } = req.body;

  if (!username || !password) {
    return res.status(400).json({ error: 'Username and password are required' });
  }

  try {
    const result = await pool.query('SELECT * FROM users WHERE username = $1', [username]);
    if (result.rows.length > 0) {
      const user = result.rows[0];
      if (await bcrypt.compare(password, user.password)) {
        const token = jwt.sign(
          { id: user.id, username: user.username },
          process.env.JWT_SECRET,
          { expiresIn: '1h' }
        );
        res.json({ token, username: user.username });
      } else {
        res.status(400).json({ error: 'Invalid credentials' });
      }
    } else {const { Pool } = require('pg');

    const pool = new Pool({
      user: process.env.DB_USER,
      host: process.env.DB_HOST,
      database: process.env.DB_NAME,
      password: process.env.DB_PASSWORD,
      port: process.env.DB_PORT,
    });
    
    module.exports = { pool };
      res.status(400).json({ error: 'User not found' });
    }
  } catch (error) {
    console.error('Error logging in:', error);
    res.status(500).json({ error: 'An error occurred while logging in' });
  }
});

module.exports = router;

================
File: package.json
================
{
  "dependencies": {
    "@react-native-async-storage/async-storage": "^2.0.0",
    "bcrypt": "^5.1.1",
    "dotenv": "^16.4.5",
    "express": "^4.21.0",
    "jsonwebtoken": "^9.0.2",
    "node-fetch": "^2.7.0",
    "openai": "^4.61.0",
    "pg": "^8.13.0"
  }
}

================
File: petRoutes.js
================
const express = require('express');
const { pool } = require('./db');
const { authenticateToken } = require('./authMiddleware');

const router = express.Router();

// Add a pet
router.post('/add', authenticateToken, async (req, res) => {
  const { name, breed, birthday } = req.body;
  const userId = req.user.id; // Get user ID from authenticated token

  if (!name) {
    return res.status(400).json({ error: 'Pet name is required' });
  }

  const client = await pool.connect();
  try {
    const result = await client.query(
      'INSERT INTO pets (user_id, name, breed, birthday) VALUES ($1, $2, $3, $4) RETURNING id',
      [userId, name, breed, birthday]
    );
    res.status(201).json({ id: result.rows[0].id, message: 'Pet added successfully' });
  } catch (error) {
    console.error('Error adding pet:', error);
    res.status(500).json({ error: 'An error occurred while adding the pet' });
  } finally {
    client.release();
  }
});

// Get pet details
router.get('/:id', authenticateToken, async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id; // Get user ID from authenticated token

  const client = await pool.connect();
  try {
    const petResult = await client.query('SELECT * FROM pets WHERE id = $1 AND user_id = $2', [id, userId]);
    
    if (petResult.rows.length === 0) {
      return res.status(404).json({ error: 'Pet not found' });
    }

    const pet = petResult.rows[0];

    const emotionRecordsResult = await client.query(
      'SELECT er.*, array_agg(tr.tip) as tips_and_recs FROM emotion_records er ' +
      'LEFT JOIN tips_and_recs tr ON er.id = tr.emotion_record_id ' +
      'WHERE er.pet_id = $1 ' +
      'GROUP BY er.id ' +
      'ORDER BY er.timestamp DESC',
      [id]
    );

    pet.emotionHistory = emotionRecordsResult.rows;

    res.json(pet);
  } catch (error) {
    console.error('Error fetching pet details:', error);
    res.status(500).json({ error: 'An error occurred while fetching pet details' });
  } finally {
    client.release();
  }
});

module.exports = router;

================
File: server.js
================
const express = require('express');
require('dotenv').config();

const authRoutes = require('./authRoutes');
const petRoutes = require('./petRoutes');
const catRoutes = require('./catRoutes');
const { pool } = require('./db');

const app = express();
const port = process.env.PORT || 3000;

app.use(express.json({ limit: '50mb' }));

// Use routes
app.use('/auth', authRoutes);
app.use('/pets', petRoutes);
app.use('/cats', catRoutes);

// Initialize database tables
async function initDatabase() {
  const client = await pool.connect();
  try {
    await client.query(`
      CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        username VARCHAR(100) UNIQUE NOT NULL,
        email VARCHAR(100) UNIQUE NOT NULL,
        password VARCHAR(100) NOT NULL
      );

      CREATE TABLE IF NOT EXISTS pets (
        id SERIAL PRIMARY KEY,
        user_id INTEGER REFERENCES users(id),
        name VARCHAR(100) NOT NULL,
        breed VARCHAR(100),
        birthday DATE
      );

      CREATE TABLE IF NOT EXISTS emotion_records (
        id SERIAL PRIMARY KEY,
        pet_id INTEGER REFERENCES pets(id),
        emotion VARCHAR(50) NOT NULL,
        emotion_text TEXT,
        image_url TEXT,
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );

      CREATE TABLE IF NOT EXISTS tips_and_recs (
        id SERIAL PRIMARY KEY,
        emotion_record_id INTEGER REFERENCES emotion_records(id),
        tip TEXT NOT NULL
      );
    `);
    console.log('Database initialized successfully');
  } catch (err) {
    console.error('Error initializing database:', err);
  } finally {
    client.release();
  }
}

initDatabase();

app.listen(port, () => {
  console.log(`Server running on port ${port}`);
});
